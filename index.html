<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animation Studio</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel to compile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // --- LocalStorage Hook for Data Persistence ---
        const useLocalStorage = (key, initialValue) => {
          const [storedValue, setStoredValue] = useState(() => {
            try {
              const item = window.localStorage.getItem(key);
              return item ? JSON.parse(item) : initialValue;
            } catch (error) {
              console.error("Error reading from localStorage", error);
              return initialValue;
            }
          });

          const setValue = (value) => {
            try {
              const valueToStore = value instanceof Function ? value(storedValue) : value;
              setStoredValue(valueToStore);
              window.localStorage.setItem(key, JSON.stringify(valueToStore));
            } catch (error) {
              console.error("Error writing to localStorage", error);
            }
          };
          return [storedValue, setValue];
        };

        // --- Icon Components (SVG replacements) ---
        const AlertTriangle = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg>
        );
        const PlusCircle = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"></circle><path d="M8 12h8"></path><path d="M12 8v8"></path></svg>
        );
        const Trash2 = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
        );
        const Home = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
        );
        const UploadCloud = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"></path><path d="M12 12v9"></path><path d="m16 16-4-4-4 4"></path></svg>
        );
        const Loader2 = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg>
        );
        const Clipboard = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="8" height="4" x="8" y="2" rx="1" ry="1"></rect><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path></svg>
        );
        const RefreshCw = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"></path><path d="M21 3v5h-5"></path><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"></path><path d="M3 21v-5h5"></path></svg>
        );
        const ArrowRight = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg>
        );
        const Wand2 = ({ className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.71 0L11.5 9.51l8.84 8.84 7.15-7.15a1.21 1.21 0 0 0 0-1.71l-1.27-1.28zM11.5 9.51 2.66 18.35l-1.28-1.27a1.21 1.21 0 0 1 0-1.71l8.84-8.84-1.71-1.71a1.21 1.21 0 0 0-1.71 0l-1.28 1.28-2.55-2.55a1.21 1.21 0 0 0-1.71 0L1 4.9l8.84 8.84 2.55-2.55.51-.51z"></path></svg>
        );


        // --- Helper Components ---
        const Button = ({ onClick, children, disabled = false, className = '', variant = 'primary' }) => {
          const baseClasses = 'flex items-center justify-center gap-2 px-4 py-2 font-semibold rounded-lg shadow-md transition-all duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900';
          const variants = {
            primary: 'text-white bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-500',
            secondary: 'text-gray-200 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-500',
            danger: 'text-white bg-red-600 hover:bg-red-700 disabled:bg-red-400',
            warning: 'bg-yellow-600/20 hover:bg-yellow-600/40 text-yellow-300'
          };
          return (
            <button onClick={onClick} disabled={disabled} className={`${baseClasses} ${variants[variant]} ${className}`}>
                {children}
            </button>
          );
        };

        const ConfirmationModal = ({ project, onConfirm, onCancel }) => {
            if (!project) return null;
            return (
                <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50">
                    <div className="bg-gray-800 border border-gray-700 rounded-xl p-6 max-w-sm w-full mx-4">
                        <div className="flex items-center gap-4 mb-4">
                            <div className="flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-500/20">
                                <AlertTriangle className="h-6 w-6 text-red-400" />
                            </div>
                            <div>
                                <h3 className="text-lg font-bold text-white">Delete Project</h3>
                                <p className="text-sm text-gray-400">{`Are you sure you want to delete "${project.name}"? This action cannot be undone.`}</p>
                            </div>
                        </div>
                        <div className="flex justify-end gap-3 mt-6">
                            <Button onClick={onCancel} variant="secondary">Cancel</Button>
                            <Button onClick={onConfirm} variant="danger">Delete</Button>
                        </div>
                    </div>
                </div>
            );
        };


        // --- Main App: Manages Views (Dashboard vs. Workspace) ---
        function App() {
          const [projects, setProjects] = useLocalStorage('animation-projects', []);
          const [currentProjectId, setCurrentProjectId] = useState(null);
          const [librariesLoaded, setLibrariesLoaded] = useState(false);
          const [libraryError, setLibraryError] = useState('');
          const [projectToDelete, setProjectToDelete] = useState(null);

          useEffect(() => {
            const loadScript = (url) => {
                return new Promise((resolve, reject) => {
                    const existingScript = document.querySelector(`script[src="${url}"]`);
                    if (existingScript) {
                        resolve();
                        return;
                    }
                    const script = document.createElement('script');
                    script.src = url;
                    script.async = true;
                    script.onload = resolve;
                    script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                    document.body.appendChild(script);
                });
            };

            loadScript('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js')
            .then(() => {
                if (window.pdfjsLib) {
                    window.pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;
                }
                setLibrariesLoaded(true);
            }).catch(error => {
                console.error(error);
                setLibraryError('Failed to load necessary libraries. Please refresh the page.');
            });
          }, []);

          const createNewProject = () => {
            const newProject = {
              id: `proj_${Date.now()}`,
              name: 'Untitled Project',
              author: 'Unknown Author',
              storyText: '',
              totalPages: 0,
              scenes: {},
              createdAt: new Date().toISOString(),
            };
            setProjects(prev => [...prev, newProject]);
            setCurrentProjectId(newProject.id);
          };

          const confirmDeleteProject = () => {
              if (projectToDelete) {
                  setProjects(prev => prev.filter(p => p.id !== projectToDelete.id));
                  setProjectToDelete(null);
                  if (currentProjectId === projectToDelete.id) {
                      setCurrentProjectId(null);
                  }
              }
          };
          
          const updateProject = useCallback((projectId, updatedData) => {
            setProjects(prev => prev.map(p => p.id === projectId ? { ...p, ...updatedData } : p));
          }, [setProjects]);

          const currentProject = projects.find(p => p.id === currentProjectId);

          if (!librariesLoaded) {
              return <div className="min-h-screen bg-gray-900 text-gray-200 flex items-center justify-center"><Loader2 className="animate-spin mr-2" />Loading Libraries...</div>;
          }
          
          if (libraryError) {
              return <div className="min-h-screen bg-gray-900 text-red-400 flex items-center justify-center p-4 text-center"><AlertTriangle className="mr-2" />{libraryError}</div>;
          }

          if (currentProjectId && currentProject) {
            return (
              <ProjectWorkspace
                project={currentProject}
                updateProject={updateProject}
                goToDashboard={() => setCurrentProjectId(null)}
                libraryError={libraryError}
              />
            );
          }

          return (
            <>
                <ConfirmationModal 
                    project={projectToDelete} 
                    onConfirm={confirmDeleteProject} 
                    onCancel={() => setProjectToDelete(null)} 
                />
                <ProjectsDashboard
                  projects={projects}
                  createNewProject={createNewProject}
                  deleteProject={(project) => setProjectToDelete(project)}
                  selectProject={setCurrentProjectId}
                />
            </>
          );
        }

        // --- Projects Dashboard View ---
        const ProjectsDashboard = ({ projects, createNewProject, deleteProject, selectProject }) => (
          <div className="min-h-screen bg-gray-900 text-gray-200 font-sans p-4 sm:p-6 lg:p-8">
            <div className="max-w-4xl mx-auto">
              <header className="text-center mb-8">
                <h1 className="text-4xl sm:text-5xl font-extrabold text-white tracking-tight">Animation Studio</h1>
                <p className="mt-4 text-lg text-gray-400">Your projects are saved in your browser's local storage.</p>
              </header>
              <div className="mb-8">
                <Button onClick={createNewProject}> 
                    <PlusCircle size={20} /> New Project
                </Button>
              </div>
              <div className="space-y-4">
                {projects.length > 0 ? projects.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).map(p => (
                  <div key={p.id} className="bg-gray-800/50 border border-gray-700 rounded-xl p-4 flex justify-between items-center transition hover:border-indigo-500">
                    <div>
                      <h2 className="text-xl font-bold text-white">{p.name}</h2>
                      <p className="text-sm text-gray-400">{`By ${p.author || 'Unknown'} | ${p.totalPages || 0} Pages | Created: ${new Date(p.createdAt).toLocaleDateString()}`}</p>
                    </div>
                    <div className="flex gap-2">
                      <Button onClick={() => selectProject(p.id)} variant="secondary">Open</Button>
                      <Button onClick={() => deleteProject(p)} variant="danger"><Trash2 size={16} /></Button>
                    </div>
                  </div>
                )) : (
                  <div className="text-center text-gray-500 border-2 border-dashed border-gray-700 rounded-lg p-12">
                    <h3 className="text-xl font-medium text-gray-300">No projects yet</h3>
                    <p className="mt-2">Click "New Project" to start creating your animation!</p>
                  </div>
                )}
              </div>
            </div>
          </div>
        );

        // --- Project Workspace View ---
        const ProjectWorkspace = ({ project, updateProject, goToDashboard, libraryError }) => {
            const [currentSceneId, setCurrentSceneId] = useState('cover');
            const [error, setError] = useState('');
            
            useEffect(() => {
                if (project.storyText) {
                    const navItems = ['cover', ...Array.from({ length: project.totalPages }, (_, i) => String(i + 1)), 'end'];
                    const firstPendingScene = navItems.find(id => !project.scenes[id] || project.scenes[id].status !== 'completed');
                    setCurrentSceneId(firstPendingScene || 'end');
                } else {
                    setCurrentSceneId('cover');
                }
            }, [project.id]);

            return (
                <div className="min-h-screen bg-gray-900 text-gray-200 font-sans flex flex-col md:flex-row">
                    <PageNavigation project={project} currentSceneId={currentSceneId} setCurrentSceneId={setCurrentSceneId} goToDashboard={goToDashboard} />
                    <main className="flex-1 p-4 sm:p-6 lg:p-8 overflow-y-auto" style={{maxHeight: '100vh'}}>
                         <header className="mb-8 flex justify-between items-start">
                            <div>
                                <h1 className="text-3xl font-bold text-white">{project.name}</h1>
                                <p className="text-md text-gray-400">{`By: ${project.author}`}</p>
                            </div>
                         </header>
                         {error && (
                            <div className="w-full bg-red-500/20 border border-red-500 text-red-300 p-4 rounded-lg mb-4 flex gap-2">
                                <AlertTriangle className="flex-shrink-0" />
                                <p><span className="font-bold">Error: </span>{error}</p>
                            </div>
                        )}
                         {libraryError && (
                            <div className="w-full bg-red-500/20 border border-red-500 text-red-300 p-4 rounded-lg mb-4 flex gap-2">
                                <AlertTriangle className="flex-shrink-0" />
                                <p><span className="font-bold">Library Error: </span>{libraryError}</p>
                            </div>
                        )}
                        <SceneGenerator project={project} updateProject={updateProject} currentSceneId={currentSceneId} setCurrentSceneId={setCurrentSceneId} setError={setError} />
                    </main>
                </div>
            );
        };

        // --- Page Navigation Sidebar ---
        const PageNavigation = ({ project, currentSceneId, setCurrentSceneId, goToDashboard }) => {
            const navItems = project.totalPages > 0 ? ['cover', ...Array.from({ length: project.totalPages }, (_, i) => String(i + 1)), 'end'] : [];
            
            const firstPendingSceneIndex = navItems.findIndex(id => !project.scenes[id] || project.scenes[id].status !== 'completed');

            return (
                <nav className="w-full md:w-64 bg-gray-900/50 border-b md:border-b-0 md:border-r border-gray-800 p-4 flex flex-col">
                    <Button onClick={goToDashboard} variant="secondary" className="mb-6"><Home size={16} /> Dashboard</Button>
                    {navItems.length > 0 && <h3 className="text-lg font-semibold text-white mb-4">Project Pages</h3>}
                    <ul className="space-y-2">
                        {navItems.map((id, index) => {
                            const isCurrent = id === currentSceneId;
                            const isDisabled = firstPendingSceneIndex !== -1 && index > firstPendingSceneIndex;

                            let label = '';
                            if (id === 'cover') label = 'Cover';
                            else if (id === 'end') label = 'End Scene';
                            else label = `Page ${id}`;

                            return (
                                <li key={id}>
                                    <button
                                        onClick={() => !isDisabled && setCurrentSceneId(id)}
                                        disabled={isDisabled}
                                        className={`w-full text-left px-3 py-2 rounded-md text-sm transition-colors ${
                                            isCurrent ? 'bg-indigo-600 text-white' : 'text-gray-300 hover:bg-gray-700'
                                        } ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                                    >
                                        {label}
                                    </button>
                                </li>
                            );
                        })}
                    </ul>
                </nav>
            );
        };

        // --- Scene Generator: The Core Logic Component ---
        const SceneGenerator = ({ project, updateProject, currentSceneId, setCurrentSceneId, setError }) => {
            const currentSceneData = project.scenes[currentSceneId];

            if (!project.storyText) {
                return <LayoutUploader {...{ project, updateProject, setCurrentSceneId, setError }} />;
            }

            if (currentSceneData && currentSceneData.status === 'completed') {
                return <CompletedSceneViewer {...{ sceneId: currentSceneId, project, updateProject, setCurrentSceneId, setError }} />;
            }
            
            return <SceneGeneratorUI {...{ sceneId: currentSceneId, project, updateProject, setError }} />;
        };


        // --- Specific Scene Components ---
        const LayoutUploader = ({ project, updateProject, setCurrentSceneId, setError }) => {
            const [isFileParsing, setIsFileParsing] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [storyFile, setStoryFile] = useState(null);

            const handleFileChange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setStoryFile(file);
                setIsFileParsing(true);
                setError('');

                try {
                    setLoadingMessage('Extracting text from PDF...');
                    let coverImageBase64 = '';
                    const allPagesText = [];

                    if (file.type === 'application/pdf') {
                        if (!window.pdfjsLib) throw new Error("PDF parsing library not loaded.");
                        
                        const fileBuffer = await file.arrayBuffer();
                        const pdf = await window.pdfjsLib.getDocument(fileBuffer).promise;
                        
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            allPagesText.push({ pageNum: i, text: pageText });
                        }

                        setLoadingMessage('Extracting cover image...');
                        const coverPage = await pdf.getPage(1);
                        const viewport = coverPage.getViewport({ scale: 1.5 });
                        const canvas = document.createElement('canvas');
                        const context = canvas.getContext('2d');
                        canvas.height = viewport.height;
                        canvas.width = viewport.width;
                        await coverPage.render({ canvasContext: context, viewport: viewport }).promise;
                        coverImageBase64 = canvas.toDataURL('image/jpeg').split(',')[1];

                    } else {
                        throw new Error("Unsupported file type. Please upload a PDF file.");
                    }
                    
                    setLoadingMessage('Analyzing story content with AI...');
                    const storyContent = await findStoryContent(allPagesText, setError);
                    if (!storyContent || storyContent.length === 0) {
                        throw new Error("AI could not identify the main story pages in the document. Please check the PDF content.");
                    }

                    const totalPages = storyContent.length;
                    const storyText = storyContent.map(p => p.text).join('\n\n');
                    const scenes = { cover: { status: 'pending' }, end: { status: 'pending' } };
                    storyContent.forEach((page, index) => {
                        scenes[String(index + 1)] = { status: 'pending', text: page.text };
                    });
                    
                    const initialProjectState = { ...project, storyText, totalPages, scenes };
                    
                    setLoadingMessage('Generating opening scene...');
                    const newPrompt = await generateScene(initialProjectState, 'cover', coverImageBase64, '', setError);

                    const finalScenes = {
                        ...initialProjectState.scenes,
                        cover: { status: 'completed', prompt: newPrompt }
                    };

                    const finalProjectState = {
                        ...initialProjectState,
                        scenes: finalScenes,
                        name: newPrompt.extracted_title || project.name,
                        author: newPrompt.extracted_author || project.author,
                    };
                    
                    updateProject(project.id, finalProjectState);
                    setCurrentSceneId('cover');

                } catch (err) {
                    setError(err.message);
                } finally {
                    setIsFileParsing(false);
                }
            };

            return (
                <div className="bg-gray-800/50 p-6 rounded-lg">
                    <h3 className="text-2xl font-bold mb-4">Upload Your Book's Layout</h3>
                    <p className="text-gray-400 mb-4">Upload your book's layout as a PDF. The app will extract the text, use the first page as the cover, and automatically generate the opening scene.</p>
                    <label htmlFor="story-upload" className={`flex flex-col items-center justify-center w-full h-48 border-2 border-gray-600 border-dashed rounded-lg bg-gray-800/50 transition cursor-pointer hover:bg-gray-700/50`}>
                        {isFileParsing ? (
                            <>
                                <Loader2 className="animate-spin text-indigo-400" size={32} />
                                <p className="mt-2 text-indigo-300">{loadingMessage}</p>
                            </>
                        ) : (
                            <>
                                <UploadCloud size={32} />
                                <p className="mt-2">{storyFile ? storyFile.name : 'Click to upload'}</p>
                                <p className="text-xs text-gray-500 mt-1">PDF file only</p>
                            </>
                        )}
                        <input id="story-upload" type="file" className="hidden" accept=".pdf,application/pdf" onChange={handleFileChange} disabled={isFileParsing} />
                    </label>
                </div>
            );
        };

        const CompletedSceneViewer = ({ sceneId, project, updateProject, setCurrentSceneId, setError }) => {
            const sceneData = project.scenes[sceneId];
            const [isRegenerating, setIsRegenerating] = useState(false);
            const [copySuccess, setCopySuccess] = useState('');

            const copyToClipboard = () => {
                if (!sceneData?.prompt) return;
                const jsonString = JSON.stringify(sceneData.prompt, null, 2);
                
                const textArea = document.createElement('textarea');
                textArea.value = jsonString;
                textArea.style.position = 'fixed'; 
                textArea.style.opacity = '0';

                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                try {
                    document.execCommand('copy');
                    setCopySuccess('Copied!');
                } catch (err) {
                    setCopySuccess('Failed!');
                    console.error('Fallback: Oops, unable to copy', err);
                }

                document.body.removeChild(textArea);
                setTimeout(() => setCopySuccess(''), 2000);
            };
            
            const getNextScene = () => {
                const navItems = ['cover', ...Array.from({ length: project.totalPages }, (_, i) => String(i + 1)), 'end'];
                const currentIndex = navItems.findIndex(id => id === sceneId);
                return navItems[currentIndex + 1];
            };

            const nextSceneId = getNextScene();

            return (
                <div className="bg-gray-800/50 p-6 rounded-lg">
                    <h3 className="text-2xl font-bold mb-4">{`Completed: ${sceneId === 'cover' ? 'Cover' : sceneId === 'end' ? 'End Scene' : `Page ${sceneId}`}`}</h3>
                    
                    <div className="flex flex-wrap gap-4 items-center mb-4 pb-4 border-b border-gray-700">
                         <Button onClick={copyToClipboard} variant="primary">
                            <Clipboard size={16} /> {copySuccess || 'Copy Prompt'}
                        </Button>
                        <Button onClick={() => setIsRegenerating(prev => !prev)} variant="warning">
                            <RefreshCw size={16} /> {isRegenerating ? 'Cancel' : 'Regenerate'}
                        </Button>
                        {nextSceneId && (
                            <Button onClick={() => setCurrentSceneId(nextSceneId)} variant="secondary">
                                Go to Next Scene <ArrowRight size={16} />
                            </Button>
                        )}
                    </div>

                     <div className="bg-gray-900 mt-4 p-4 rounded-md font-mono text-sm overflow-x-auto">
                        <h4 className="text-lg font-semibold text-gray-200 mb-2">Animation Prompt</h4>
                        <pre><code>{JSON.stringify(sceneData.prompt, null, 2)}</code></pre>
                    </div>

                    {isRegenerating && (
                        <div className="mt-6 pt-6 border-t border-gray-700">
                             <SceneGeneratorUI 
                                sceneId={sceneId} 
                                project={project} 
                                updateProject={updateProject} 
                                setError={setError} 
                                isRegenerating={true}
                             />
                        </div>
                    )}
                </div>
            );
        };


        // --- Universal Scene Generation UI and Logic ---
        const SceneGeneratorUI = ({ sceneId, project, updateProject, setError, isRegenerating = false }) => {
            const [imageFile, setImageFile] = useState(null);
            const [imageBase64, setImageBase64] = useState('');
            const [feedback, setFeedback] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('Generating...');

            const handleImageChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setImageFile(file);
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setImageBase64(reader.result.split(',')[1]);
                    };
                    reader.readAsDataURL(file);
                }
            };
            
            const handleGenerate = async () => {
                if (sceneId !== 'end' && !imageBase64 && !isRegenerating) {
                    setError('Please upload an illustration for this page.');
                    return;
                }
                setIsLoading(true);
                setLoadingMessage('Generating JSON prompt...');
                setError('');

                try {
                    const newPrompt = await generateScene(project, sceneId, imageBase64, feedback, setError);
                    
                    const updatedScenes = {
                        ...project.scenes,
                        [sceneId]: {
                            ...project.scenes[sceneId],
                            status: 'completed',
                            prompt: newPrompt,
                        }
                    };
                    
                    let projectUpdates = { scenes: updatedScenes };
                    if (sceneId === 'cover' && newPrompt.extracted_title) {
                        projectUpdates.name = newPrompt.extracted_title;
                        projectUpdates.author = newPrompt.extracted_author || 'Unknown Author';
                    }

                    updateProject(project.id, projectUpdates);

                } catch (err) {
                    setError(`Operation failed: ${err.message}.`);
                } finally {
                    setIsLoading(false);
                }
            };

            const sceneText = project.scenes[sceneId]?.text;

            let headerText = '';
            if (sceneId === 'cover') headerText = 'Generate Cover Animation';
            else if (sceneId === 'end') headerText = 'Generate End Scene';
            else headerText = `Generate Animation for Page ${sceneId}`;
            if (isRegenerating) headerText = `Regenerate: ${headerText.split(' ')[1]} Scene`;


            return (
                <div className="bg-gray-800/50 p-6 rounded-lg">
                    <h3 className="text-2xl font-bold mb-4">{headerText}</h3>
                    
                    {sceneId !== 'end' && (
                        <div className="mb-4">
                            <label className="block mb-2 font-semibold text-gray-300">
                                {`Illustration for Page ${sceneId}`}
                            </label>
                            <label htmlFor="scene-image-upload" className="flex flex-col items-center justify-center w-full h-48 border-2 border-gray-600 border-dashed rounded-lg cursor-pointer hover:bg-gray-700/50">
                                {imageBase64 ? <img src={`data:image/jpeg;base64,${imageBase64}`} alt="Preview" className="max-h-full max-w-full object-contain rounded-md" /> : <><UploadCloud /> <p>{imageFile ? imageFile.name : 'Click to upload'}</p></>}
                                <input id="scene-image-upload" type="file" className="hidden" accept="image/*" onChange={handleImageChange} />
                            </label>
                        </div>
                    )}

                    {sceneText && (
                        <div className="mb-4">
                            <label className="block mb-2 font-semibold text-gray-300">Scene Text</label>
                            <p className="text-gray-400 bg-gray-900 p-4 rounded-md">{sceneText}</p>
                        </div>
                    )}
                    
                    {isRegenerating && (
                         <div className="mb-4">
                            <label htmlFor="feedback-text" className="block mb-2 font-semibold text-gray-300">What would you like to change?</label>
                            <textarea
                                id="feedback-text"
                                value={feedback}
                                onChange={(e) => setFeedback(e.target.value)}
                                placeholder="e.g., Make the character's smile bigger. Change the camera to a slow zoom in."
                                className="w-full h-24 p-3 bg-gray-900 border border-gray-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none transition"
                            />
                        </div>
                    )}
                    
                    {sceneId === 'end' && (
                        <p className="text-gray-300 mb-4">All pages are complete. The end scene will be generated using the context of the entire story.</p>
                    )}

                    <Button onClick={handleGenerate} disabled={isLoading}>
                        {isLoading ? <><Loader2 className="animate-spin" /> {loadingMessage}</> : <><Wand2 /> Generate Scene</>}
                    </Button>
                </div>
            );
        };

        // --- Reusable API and Generation Logic ---
        const storyContentSchema = {
            type: "OBJECT",
            properties: {
                story_pages: {
                    type: "ARRAY",
                    description: "An array of objects, where each object represents a page containing the main story narrative.",
                    items: {
                        type: "OBJECT",
                        properties: {
                            page_number: { type: "NUMBER", description: "The original page number from the PDF." },
                            text: { type: "STRING", description: "The narrative text from this page." }
                        },
                        required: ["page_number", "text"]
                    }
                }
            },
            required: ["story_pages"]
        };

        const findStoryContent = async (allPagesText, setError) => {
            const promptText = `
                You are a literary assistant. Analyze the following pages from a children's book.
                Your task is to identify only the pages that contain the main story narrative.
                Exclude pages that are only for titles, copyright information, dedications, table of contents, or back matter.
                Return the result as a JSON object matching the provided schema. The 'story_pages' array should be ordered chronologically.

                Here is the text from the pages:
                ${allPagesText.map(p => `Page ${p.pageNum}: "${p.text}"`).join('\n')}
            `;

            const payload = {
                contents: [{ role: "user", parts: [{ text: promptText }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: storyContentSchema,
                }
            };

            try {
                const apiUrl = `/api/proxy`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorBody}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const parsedJson = JSON.parse(jsonText);
                    return parsedJson.story_pages;
                } else {
                    console.error("API Response for story content was empty or invalid:", result);
                    throw new Error('The model returned an empty or invalid response for story content.');
                }
            } catch (err) {
                console.error("Error in findStoryContent:", err);
                setError(err.message);
                throw err;
            }
        };

        const animationPromptSchema = {
            type: "OBJECT",
            properties: {
                page_number: { type: "NUMBER" },
                scene_summary: { type: "STRING" },
                animation_style: { type: "OBJECT", properties: { style: { type: "STRING" }, color_palette: { type: "STRING" }, tone: { type: "STRING" }}},
                scene: { type: "OBJECT", properties: { location: { type: "STRING" }, time_of_day: { type: "STRING" }, environment_details: { type: "STRING" }}},
                characters: { type: "ARRAY", items: { type: "OBJECT", properties: { name: { type: "STRING" }, description: { type: "STRING" }, initial_expression: { type: "STRING" }}}},
                camera: { type: "OBJECT", properties: { shot_type: { type: "STRING" }, movement: { type: "STRING" }}},
                action: { type: "OBJECT", properties: { primary_action: { type: "STRING" }, subtle_motions: { type: "STRING" }}},
                metadata: { type: "OBJECT", properties: { estimated_duration_seconds: { type: "NUMBER" }, notes: { type: "STRING" }}},
                extracted_title: { type: "STRING" },
                extracted_author: { type: "STRING" },
            }
        };

        const buildApiPromptText = (project, sceneId, feedback) => {
            let systemInstruction = `You are an expert animation director for children's content. Your task is to analyze a single children's book scene (text and illustration) within the context of an entire story. You will generate a structured JSON object that serves as a technical animation prompt. All descriptions must be child-friendly and safe.`;
            let taskInstruction = '';
            const sceneText = project.scenes[sceneId]?.text || '';
            const fullStoryContext = project.storyText || "No story context provided yet.";

            if (sceneId === 'cover') {
                taskInstruction = `Analyze the attached book cover image. Based on the visuals, generate a dynamic opening title sequence animation. IMPORTANT: Also, extract the book's title and author's name from the cover image text. Populate the 'extracted_title' and 'extracted_author' fields in the JSON. The animation should hint at the story's main themes and characters.`;
            } else if (sceneId === 'end') {
                taskInstruction = `All pages are complete. Generate a concluding animation prompt. This should be a gentle, summary scene, perhaps a final shot of the main character or a pan across the main setting, evoking a feeling of happy resolution. Use the full story context for inspiration.`;
            } else {
                taskInstruction = `Analyze the attached illustration and its corresponding text for Page ${sceneId}. Generate a detailed animation prompt based on these assets, interpreted within the broader context of the full story provided below.`;
            }
            
            if (feedback) {
                taskInstruction += `\n\nREGENERATION FEEDBACK: The previous attempt was not quite right. Please regenerate the JSON, taking this user feedback into account: "${feedback}"`;
            }
            
            return `
                SYSTEM INSTRUCTION: ${systemInstruction}
                FULL STORY CONTEXT:
                ${fullStoryContext}
                ---
                CURRENT SCENE ANALYSIS TASK:
                - Scene ID: ${sceneId}
                - Scene Text (if applicable): "${sceneText}"
                - Task: ${taskInstruction}
                Now, populate the JSON schema based on this task.
            `;
        };

        const generateScene = async (project, sceneId, imageBase64, feedback, setError) => {
            const textPrompt = buildApiPromptText(project, sceneId, feedback);
            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: textPrompt },
                        ...(imageBase64 ? [{ inlineData: { mimeType: 'image/jpeg', data: imageBase64 } }] : [])
                    ]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: animationPromptSchema,
                }
            };

            try {
                const apiUrl = `/api/proxy`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorBody}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts[0].text) {
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const newPrompt = JSON.parse(jsonText);
                    return newPrompt;
                } else {
                    console.error("API Response was empty or invalid:", result);
                    throw new Error('The model returned an empty or invalid response.');
                }
            } catch (err) {
                console.error("Error in generateScene:", err);
                setError(err.message);
                throw err;
            }
        };

        // Mount the React App to the 'root' div in the HTML.
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
